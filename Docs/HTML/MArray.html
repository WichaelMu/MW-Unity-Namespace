<!DOCTYPE html><html lang=en><head><title>Home | MICHAEL WU</title><link rel=stylesheet href=MWUnityNamespace.css><meta charset=UTF-8></head><body><div class=header id=top>MW UNITY NAMESPACE</div><div style="width: 100%; display: table;"><div style="display: table-row"><div style="width: 200px; display: table-cell;"><div class="navLinks"><a href=Audio.html>Audio</a></div><br><div class="navLinks"><a href=Behaviour.html>Behaviour</a></div><br><div class="navLinks"><a href=CameraUtils.html>CameraUtils</a></div><br><div class="navLinks"><a href=Conversion.html>Conversion</a></div><br><div class="navLinks"><a href=Diagnostics.html>Diagnostics</a></div><br><div class="navLinks"><a href=EButton.html>EButton</a></div><br><div class="navLinks"><a href=EComponentAxis.html>EComponentAxis</a></div><br><div class="navLinks"><a href=EDirection.html>EDirection</a></div><br><div class="navLinks"><a href=EEquation.html>EEquation</a></div><br><div class="navLinks"><a href=EUnit.html>EUnit</a></div><br><div class="navLinks"><a href=Easing.html>Easing</a></div><br><div class="navLinks"><a href=HUD.html>HUD</a></div><br><div class="navLinks"><a href=IHeapItem.html>IHeapItem</a></div><br><div class="navLinks"><a href=IO.html>IO</a></div><br><div class="navLinks"><a href=Kinetic.html>Kinetic</a></div><br><div class="navLinks"><a href=MArray.html>MArray</a></div><br><div class="navLinks"><a href=MRotator.html>MRotator</a></div><br><div class="navLinks"><a href=MVector.html>MVector</a></div><br><div class="navLinks"><a href=Math.html>Math</a></div><br><div class="navLinks"><a href=Pathfinding.html>Pathfinding</a></div><br><div class="navLinks"><a href=THeap.html>THeap</a></div><br><div class="navLinks"><a href=TPair2.html>TPair2</a></div><br><div class="navLinks"><a href=TTriple3.html>TTriple3</a></div><br><div class="navLinks"><a href=Utils.html>Utils</a></div><br></div><br><br><div style="display: table-cell;"><br><br><h1 class="classHead C">MArray</h1><br><p class="simplePara C">A dynamic generic array combining the functionality of a List and a Dictionary.</p><p class="basicHead">Num</p><br><p class="simplePara">The number of T in this MArray; the size.</p><h1 class="basicHead">CONSTRUCTOR ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Initialises an MArray with the default settings.</p><h1 class="basicHead">CONSTRUCTOR (int InitialSize)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Initialises an MArray with an initial capacity.</p><p class="keyword">Params:</p><p class="simplePara">InitialSize: The number of elements this MArray will begin with.</p><h1 class="basicHead">Push (T Item)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Adds Item.</p><p class="keyword">Params:</p><p class="simplePara">Item: The unique element to add.</p><p class="keyword">Returns:</p><p class="simplePara">If Pushing Item was successful. True if Item does not already exist in this MArray.</p><h1 class="basicHead">Push (T[] Range)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Adds Range of items.</p><p class="keyword">Params:</p><p class="simplePara">Range: The list of elements to add.</p><p class="keyword">Returns:</p><p class="simplePara">An MArray of PushRangeFailed{T} that failed to be pushed into this MArray.</p><h1 class="basicHead">Pull (T Item)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Removes Item.</p><p class="keyword">Params:</p><p class="simplePara">Item: The element to remove.</p><p class="keyword">Returns:</p><p class="simplePara">The new size of this MArray.</p><h1 class="basicHead">Random ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Any element.</p><p class="keyword">Returns:</p><p class="simplePara">Any random element.</p><h1 class="basicHead">First ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The item at the front of the queue.</p><p class="keyword">Returns:</p><p class="simplePara">The item at the front of the queue.</p><h1 class="basicHead">FirstPop ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Pops the item at the front of the queue.</p><p class="keyword">Returns:</p><p class="simplePara">The item that was at the front of the queue.</p><h1 class="basicHead">Top ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The item at the top of the stack.</p><p class="keyword">Returns:</p><p class="simplePara">The item at the top of the stack.</p><h1 class="basicHead">TopPop ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Pops the item at the top of the stack.</p><p class="keyword">Returns:</p><p class="simplePara">The item at the top of the stack.</p><h1 class="basicHead">InRange (int Index)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Whether or not Index is within range.</p><p class="keyword">Params:</p><p class="simplePara">Index: The Index to check for range.</p><p class="keyword">Returns:</p><p class="simplePara">If Index is greater than or equal to zero and less than the number of elements.</p><h1 class="basicHead">Contains (T Item)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Item to check for existence.</p><p class="keyword">Params:</p><p class="simplePara">Item: Item to check for existence.</p><p class="keyword">Returns:</p><p class="simplePara">Whether the HashCode of Item exists within the internal HashMap.</p><h1 class="basicHead">Flush ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Clears this MArray.</p><h1 class="basicHead">IsEmpty ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">If this MArray is considered empty; Num == 0.</p><p class="keyword">Returns:</p><p class="simplePara">If this MArray is considered empty; Num == 0.</p><h1 class="basicHead">Mirror ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The mirror position of index over minimum zero, maximum Num.</p><p class="keyword">Returns:</p><p class="simplePara">The mirror position of index over minimum zero, maximum Num.</p><h1 class="basicHead">Mirror ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The mirror position of index over Minimum to maximum Num.</p><p class="keyword">Returns:</p><p class="simplePara">The mirror position of index over Minimum to maximum Num.</p><h1 class="basicHead">Reflect ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The incoming and reflected Item of this mirror from zero to maximum Num.</p><p class="keyword">Returns:</p><p class="simplePara">Reflected</p><h1 class="basicHead">Reflect ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The incoming and reflected Item of this mirror from Minimum to maximum Num.</p><p class="keyword">Returns:</p><p class="simplePara">Reflected</p><h1 class="basicHead">Reflect ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Reflects over Minimum, Maximum with Index.</p><p class="keyword">Returns:</p><p class="simplePara">Outs the incoming and reflected Item of this mirror of Minimum, maximum Num.</p><h1 class="basicHead">Item (int i)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Square bracket accessor.</p><p class="keyword">Params:</p><p class="simplePara">i: The index to access T item.</p><p class="keyword">Returns:</p><p class="simplePara">The Item at the specified index.</p><h1 class="basicHead">CheckNull (MArrayT Check)</h1><br><p class="keyword">Summary:</p><p class="simplePara">The MArray to check for initialisation.</p><p class="keyword">Params:</p><p class="simplePara">Check: The MArray to check for initialisation.</p><p class="keyword">Returns:</p><p class="simplePara">True if Check is null.</p><h1 class="basicHead">op_LogicalNot (MArrayT CheckIfNullOrEmpty)</h1><br><p class="keyword">Summary:</p><p class="simplePara">If this MArray is null or IsEmpty.</p><p class="keyword">Params:</p><p class="simplePara">CheckIfNullOrEmpty: The MArray to check for null or emptiness.</p><p class="keyword">Returns:</p><p class="simplePara">True if CheckIfNullOrEmpty is null or empty.</p><h1 class="basicHead">op_Addition (MArrayT Left, MArrayT Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Adds Right to the end of Left.</p><p class="keyword">Params:</p><p class="simplePara">Left: The MArray to append to.</p><p class="simplePara">Right: The MArray to append to Left.</p><p class="keyword">Returns:</p><p class="simplePara">A contiguous MArray from Left to Right.</p><h1 class="basicHead">op_BitwiseAnd (MArrayT Left, MArrayT Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Left elements that exist in Right.</p><p class="keyword">Params:</p><p class="simplePara">Left: The MArray to check AND.</p><p class="simplePara">Right: The MArray to compare to.</p><p class="keyword">Returns:</p><p class="simplePara">An MArray of Left elements that also exist in Right.</p><h1 class="basicHead">op_ExclusiveOr (MArrayT Left, MArrayT Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Left elements that do not exist in Right.</p><p class="keyword">Params:</p><p class="simplePara">Left: The MArray to check OR.</p><p class="simplePara">Right: The MArray to compare to.</p><p class="keyword">Returns:</p><p class="simplePara">An MArray of Left's elements that do not exist in Right.</p><br><br><h1 class="classHead C">Reflected</h1><br><p class="simplePara C">The incoming and reflected Item of this mirror over the provided Minimum and Maximum Num.</p><p class="basicHead">Source</p><br><p class="simplePara">In reflection.</p><p class="basicHead">Reflection</p><br><p class="simplePara">Out reflection.</p><br><br><h1 class="classHead C">PushRangeFailed</h1><br><p class="simplePara C">A struct containing which T failed to be pushed into an MArray of T.</p><p class="basicHead">AttemptedItemToAdd</p><br><p class="simplePara">The T that couldn't be added into the MArray.</p><p class="basicHead">IndexOfAttempt</p><br><p class="simplePara">The index of the T in range that couldn't be added.</p></div></div></div></body></html>