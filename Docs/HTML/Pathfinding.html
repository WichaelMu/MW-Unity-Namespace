<!DOCTYPE html><html lang="en"><head><title>Pathfinding | MW Unity Namespace</title><link rel="stylesheet" href="CSS/MWUnityNamespace.css"><meta charset=UTF-8></head><body><div class="header" id="top">MW UNITY NAMESPACE</div><div style="width: 100%; display: table;"><div style="display: table-row"><div style="width: 200px; display: table-cell;"><div class="navLinks"><a href="Audio.html">Audio</a></div><br><div class="navLinks"><a href="Behaviour.html">Behaviour</a></div><br><div class="navLinks"><a href="CameraUtils.html">CameraUtils</a></div><br><div class="navLinks"><a href="Console.html">Console</a></div><br><div class="navLinks"><a href="Conversion.html">Conversion</a></div><br><div class="navLinks"><a href="Diagnostics.html">Diagnostics</a></div><br><div class="navLinks"><a href="EButton.html">EButton</a></div><br><div class="navLinks"><a href="EComponentAxis.html">EComponentAxis</a></div><br><div class="navLinks"><a href="EDirection.html">EDirection</a></div><br><div class="navLinks"><a href="EEquation.html">EEquation</a></div><br><div class="navLinks"><a href="EUnit.html">EUnit</a></div><br><div class="navLinks"><a href="Easing.html">Easing</a></div><br><div class="navLinks"><a href="Extensions.html">Extensions</a></div><br><div class="navLinks"><a href="FMath.html">FMath</a></div><br><div class="navLinks"><a href="FVector.html">FVector</a></div><br><div class="navLinks"><a href="HUD.html">HUD</a></div><br><div class="navLinks"><a href="HUD.Line.html">HUD.Line</a></div><br><div class="navLinks"><a href="HUD.UI.html">HUD.UI</a></div><br><div class="navLinks"><a href="IHeapItem.html">IHeapItem</a></div><br><div class="navLinks"><a href="IO.html">IO</a></div><br><div class="navLinks"><a href="Kinetic.html">Kinetic</a></div><br><div class="navLinks"><a href="MArray.html">MArray</a></div><br><div class="navLinks"><a href="MRotator.html">MRotator</a></div><br><div class="navLinks"><a href="MVector.html">MVector</a></div><br><div class="navLinks"><a href="Math.html">Math</a></div><br><div class="navLinks"><a href="Math.Magic.html">Math.Magic</a></div><br><div class="navLinks"><a href="Memory.html">Memory</a></div><br><div class="navLinks"><a href="Pathfinding.html">Pathfinding</a></div><br><div class="navLinks"><a href="THeap.html">THeap</a></div><br><div class="navLinks"><a href="TPair2.html">TPair2</a></div><br><div class="navLinks"><a href="TTriple3.html">TTriple3</a></div><br><div class="navLinks"><a href="Utils.html">Utils</a></div><br></div><br><br><div style="display: table-cell;"><pre class="C" style="padding-right:25%;color:rgb(126, 252, 202);"><br>public class : MonoBehaviour </pre></pre><h1 class="DefinedType C">DynamicPathfinding</h1><br><p class="simplePara C">Dynamic Pathfinding that adapts to the world environment.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public bool </pre><p class="FuncTitle">bDrawGizmos</p><p class="simplePara">Draw the Pathfinding bounding box.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public bool </pre><p class="FuncTitle">GizmoOptions</p><p class="simplePara">Draw the positions of the individual nodes.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] Vector3 </pre><p class="FuncTitle">LocalCentre</p><p class="simplePara">The local centre of the bounding box.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] Vector3Int </pre><p class="FuncTitle">Bounds</p><p class="simplePara">The Width, Height, and Depth of the Pathfinding box.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] LayerMask </pre><p class="FuncTitle">TraversableLayer</p><p class="simplePara">The layer/s that can be walked on.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] [Min(1)] float </pre><p class="FuncTitle">PointsPerUnit</p><p class="simplePara">The number of Nodes per Unity-world unit.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] bool </pre><p class="FuncTitle">bAirIsTraversable</p><p class="simplePara">Make the Traversable Layer <not> traversable.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] bool </pre><p class="FuncTitle">bCheckInsideContacts</p><p class="simplePara">Whether or not to check if Nodes inside a contact is traversable.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] EInsideContactQueryMethod </pre><p class="FuncTitle">InsideContactMethod</p><p class="simplePara">The method to use to determine if a point is inside a Collider.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] bool </pre><p class="FuncTitle">bIsDynamic</p><p class="simplePara">True if this should adapt to the world environment.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] [Min(1)] int </pre><p class="FuncTitle">FramesBetweenUpdate</p><p class="simplePara">The number of frames between each dynamic update to the Pathfinding Nodes.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] [Min(1)] int </pre><p class="FuncTitle">NodesPerUpdate</p><p class="simplePara">The number of Nodes to update per frame.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public MArray&lt;Node&gt; </pre><p class="FuncTitle">Nodes</p><p class="simplePara">The Nodes that are considered in the Dynamic Pathfinder.</p><p class="simplePara">The order is Z, Y, X.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public void </pre><h1 class="FuncTitle">PlotPoints ()</h1><p class="keyword">Summary:</p><p class="simplePara">Plot the Nodes, adhering to Bounds.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public void </pre><h1 class="FuncTitle">ForceReconnectAll ()</h1><p class="keyword">Summary:</p><p class="simplePara">Forces all Nodes to reconnect with each other.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public bool </pre><h1 class="FuncTitle">Pathfind (<span class="DefinedType">Node</span> <span class="FuncParamName">Origin, </span><span class="DefinedType">Node</span> <span class="FuncParamName">Destination, </span><span class="DefinedType">MArray&lt;Node&gt;&</span> <span class="FuncParamName">Path</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">Find the shortest path from Origin to Destination.</p><p class="keyword">Params:</p><p class="ParamName">Origin: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Node to begin searching on.</p><p class="ParamName">Destination: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Node to reach.</p><p class="ParamName">Path: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The shortest path from Origin to Destination.</p><p class="keyword">Returns:</p><p class="simplePara">True if a path from Origin to Destination was found.</p><pre class="C" style="padding-right:25%;color:rgb(126, 252, 202);"><br>public enum EInsideContactQueryMethod : byte </pre></pre><h1 class="DefinedType C">EInsideContactQueryMethod</h1><br><p class="simplePara C">The method for checking if a point is inside a Collider.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"></pre><p class="FuncTitle">Raycast</p><p class="simplePara">Raycast from Contact Point to Collider Centre.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"></pre><p class="FuncTitle">Bounds</p><p class="simplePara">Use Collider Bounds to Contact Point Check.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"></pre><p class="FuncTitle">RaycastAndBounds</p><p class="simplePara">Use both Raycast and Bounds checks.</p><pre class="C" style="padding-right:25%;color:rgb(126, 252, 202);"><br>public class Node : MNode, IHeapItem&lt;Node&gt; </pre></pre><h1 class="DefinedType C">Node</h1><br><p class="simplePara C">A sample Node class for Pathfinding.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public void </pre><h1 class="FuncTitle">Push (<span class="DefinedType">Node</span> <span class="FuncParamName">N</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">Registers N as a neighbour, and this as N's neighbour.</p><p class="keyword">Params:</p><p class="ParamName">N: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Neighbour.</p><pre class="C" style="padding-right:25%;color:rgb(126, 252, 202);"><br>public interface &lt;T&gt; </pre></pre><h1 class="DefinedType C">INode</h1><br><p class="simplePara C">The Interface that T must implement if it is to be used by Pathfinding.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>float </pre><p class="FuncTitle">F</p><p class="simplePara">This Node's F score.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>float </pre><p class="FuncTitle">G</p><p class="simplePara">This Node's G score.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>float </pre><p class="FuncTitle">H</p><p class="simplePara">This Node's H score.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>uint </pre><h1 class="FuncTitle">NumberOfDirections ()</h1><p class="keyword">Summary:</p><p class="simplePara">How many directions can this Node point to?</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>bool </pre><h1 class="FuncTitle">IsTraversable ()</h1><p class="keyword">Summary:</p><p class="simplePara">Is this block traversable?</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>INode&lt;T&gt; </pre><h1 class="FuncTitle">Neighbour (<span class="PrimitiveType">int</span> <span class="FuncParamName">Direction</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">Get the Neighbouring Node at Direction.</p><p class="keyword">Params:</p><p class="ParamName">Direction: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The neighbour of this Node in this direction.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>float </pre><h1 class="FuncTitle">DistanceHeuristic (<span class="DefinedType">T</span> <span class="FuncParamName">RelativeTo</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">The distance heuristic to calculate pathfinding scores.</p><p class="keyword">Params:</p><p class="ParamName">RelativeTo: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distance to from this T to Relative To.</p><p class="keyword">Returns:</p><p class="simplePara">An indicative distance from this T, Relative To.</p><pre class="C" style="padding-right:25%;color:rgb(126, 252, 202);"><br>public abstract class : INode&lt;MNode&gt;, IHeapItem&lt;MNode&gt; </pre></pre><h1 class="DefinedType C">MNode</h1><br><p class="simplePara C">Base class for Nodes to be use in A* Pathfinding.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"></pre><p class="FuncTitle">bIsTraversable</p><p class="simplePara">Is this Node an obstacle for Pathfinding?</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"></pre><p class="FuncTitle">Neighbours</p><p class="simplePara">The connected Nodes to this Node.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public abstract float </pre><h1 class="FuncTitle">DistanceHeuristic (<span class="DefinedType">MNode</span> <span class="FuncParamName">RelativeTo</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">The distance heuristic to calculate pathfinding scores.</p><p class="keyword">Params:</p><p class="ParamName">RelativeTo: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distance to from this T to Relative To.</p><p class="keyword">Returns:</p><p class="simplePara">An indicative distance from this T, Relative To.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public abstract bool </pre><h1 class="FuncTitle">IsTraversable ()</h1><p class="keyword">Summary:</p><p class="simplePara">Is this block traversable?</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>INode&lt;MNode&gt; </pre><h1 class="FuncTitle">Neighbour (<span class="PrimitiveType">int</span> <span class="FuncParamName">Direction</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">Get the Neighbouring Node at Direction.</p><p class="keyword">Params:</p><p class="ParamName">Direction: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The neighbour of this Node in this direction.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public virtual int </pre><h1 class="FuncTitle">NumberOfDirections ()</h1><p class="keyword">Summary:</p><p class="simplePara">How many directions can this Node point to?</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public static implicit operator bool </pre><h1 class="FuncTitle">MNode -> Boolean ()</h1><p class="keyword">Summary:</p><p class="simplePara">Is MNode M null?</p><pre class="C" style="padding-right:25%;color:rgb(126, 252, 202);"><br>public class &lt;T&gt; : MonoBehaviour where T : INode&lt;T&gt;, IHeapItem&lt;T&gt; </pre></pre><h1 class="DefinedType C">MPathManager</h1><br><p class="simplePara C">The MonoBehavior script that manages pathfinding over frames.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] [Min(1)] uint </pre><p class="FuncTitle">ComputationsPerFrame</p><p class="simplePara">The number of paths to compute per frame.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>[SerializeField] [Min(1)] uint </pre><p class="FuncTitle">FramesBetweenComputations</p><p class="simplePara">The number of frames between computing path/s.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public void </pre><h1 class="FuncTitle">Pause ()</h1><p class="keyword">Summary:</p><p class="simplePara">Temporarily stop the computation of paths.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public void </pre><h1 class="FuncTitle">Resume ()</h1><p class="keyword">Summary:</p><p class="simplePara">Continue the computation of paths.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public EStatus </pre><h1 class="FuncTitle">Status ()</h1><p class="keyword">Summary:</p><p class="simplePara">Prints the current status of this Path Manager.</p><p class="keyword">Returns:</p><p class="simplePara">If this Path Manager is currently Paused, or Running.</p><pre class="C" style="padding-right:25%;color:rgb(126, 252, 202);"><br>public static class &lt;T&gt; where T : MNode, IHeapItem&lt;T&gt; </pre></pre><h1 class="DefinedType C">Pathfinding</h1><br><p class="simplePara C">Provides the A* Pathfinding implementation for T.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public static bool </pre><h1 class="FuncTitle">AStar (<span class="DefinedType">T</span> <span class="FuncParamName">Origin, </span><span class="DefinedType">Y</span> <span class="FuncParamName">Destination, </span><span class="DefinedType">MArray&lt;T&gt;&</span> <span class="FuncParamName">Path, </span><span class="DefinedType">UInt32</span> <span class="FuncParamName">Depth, </span><span class="DefinedType">UInt32</span> <span class="FuncParamName">MapSize, </span><span class="PrimitiveType">bool</span> <span class="FuncParamName">bUseDiagnostics</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">A* pathfinds from Origin to Destination looking uDepth times within a uMapSize.</p><p class="keyword">Params:</p><p class="ParamName">Origin: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T position to begin pathfinding.</p><p class="ParamName">Destination: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T position to pathfind to.</p><p class="ParamName">Path: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reference T List of that make up the path from Origin to Destination.</p><p class="ParamName">Depth: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The depth to search to.</p><p class="ParamName">MapSize: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The total size of the map to be traversed. (The number of INodes).</p><p class="ParamName">bUseDiagnostics: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time the duration of Pathfinding?</p><p class="keyword">Returns:</p><p class="simplePara">Whether or not a path was found from Origin to Destination within uDepth in uMapSize.</p><pre class="C" style="padding-right:25%;color:rgb(126, 252, 202);"><br>public static class &lt;T&gt; where T : INode&lt;T&gt;, IHeapItem&lt;T&gt; </pre></pre><h1 class="DefinedType C">PathRegister</h1><br><p class="simplePara C">Computes a number of paths over a number of frames.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public static void </pre><h1 class="FuncTitle">RequestPath (<span class="DefinedType">T</span> <span class="FuncParamName">Origin, </span><span class="DefinedType">Y</span> <span class="FuncParamName">Destination, </span><span class="DefinedType">Action&lt;System.Collections.Generic.List{</span> <span class="FuncParamName">OnPathCalculated, </span><span class="DefinedType">Action&lt;System.Collections.Generic.List{</span> <span class="FuncParamName">OnPathFailed</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">Register a path to compute when possible.</p><p class="keyword">Remarks:</p><p class="simplePara">This is on a first-in, first-out basis. A Queue.</p><p class="keyword">Params:</p><p class="ParamName">Origin: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T position to begin pathfinding.</p><p class="ParamName">Destination: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T position to pathfind to.</p><p class="ParamName">OnPathCalculated: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What to do when a path is found? List of T pathway.</p><p class="ParamName">OnPathFailed: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What to do when a path cannot be found? List of T pathway attempt.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public static bool </pre><h1 class="FuncTitle">ComputeNext ()</h1><p class="keyword">Summary:</p><p class="simplePara">Computes the next path in FIFO.</p><p class="keyword">Returns:</p><p class="simplePara">Whether or not a computation was executed.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public static void </pre><h1 class="FuncTitle">ComputeBatch (<span class="DefinedType">UInt32</span> <span class="FuncParamName">BatchSize</span>)</h1><p class="keyword">Summary:</p><p class="simplePara">Computes BatchSize paths in a single call.</p><p class="keyword">Params:</p><p class="ParamName">BatchSize: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of paths to compute.</p><br><pre style="padding-right:25%;color:rgb(126, 252, 202);font-weight:549"><br>public static uint </pre><h1 class="FuncTitle">GetPathQueueSize ()</h1><p class="keyword">Summary:</p><p class="simplePara">Gets the number of agents waiting to compute paths.</p><p class="keyword">Returns:</p><p class="simplePara">Unsigned integer number of T's awaiting a path.</p></div></div></div></body></html>