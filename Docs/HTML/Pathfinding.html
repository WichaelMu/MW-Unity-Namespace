<!DOCTYPE html><html lang=en><head><title>Pathfinding | MW Unity Namespace</title><link rel=stylesheet href=CSS/MWUnityNamespace.css><meta charset=UTF-8></head><body><div class=header id=top>MW UNITY NAMESPACE</div><div style="width: 100%; display: table;"><div style="display: table-row"><div style="width: 200px; display: table-cell;"><div class="navLinks"><a href=Audio.html>Audio</a></div><br><div class="navLinks"><a href=Behaviour.html>Behaviour</a></div><br><div class="navLinks"><a href=CameraUtils.html>CameraUtils</a></div><br><div class="navLinks"><a href=Console.html>Console</a></div><br><div class="navLinks"><a href=Conversion.html>Conversion</a></div><br><div class="navLinks"><a href=Debugger.html>Debugger</a></div><br><div class="navLinks"><a href=Diagnostics.html>Diagnostics</a></div><br><div class="navLinks"><a href=EButton.html>EButton</a></div><br><div class="navLinks"><a href=EComponentAxis.html>EComponentAxis</a></div><br><div class="navLinks"><a href=EDirection.html>EDirection</a></div><br><div class="navLinks"><a href=EEquation.html>EEquation</a></div><br><div class="navLinks"><a href=EUnit.html>EUnit</a></div><br><div class="navLinks"><a href=Easing.html>Easing</a></div><br><div class="navLinks"><a href=Extensions.html>Extensions</a></div><br><div class="navLinks"><a href=FVector.html>FVector</a></div><br><div class="navLinks"><a href=HUD.html>HUD</a></div><br><div class="navLinks"><a href=HUD.Line.html>HUD.Line</a></div><br><div class="navLinks"><a href=HUD.UI.html>HUD.UI</a></div><br><div class="navLinks"><a href=IHeapItem.html>IHeapItem</a></div><br><div class="navLinks"><a href=IO.html>IO</a></div><br><div class="navLinks"><a href=Kinetic.html>Kinetic</a></div><br><div class="navLinks"><a href=MArray.html>MArray</a></div><br><div class="navLinks"><a href=MRotator.html>MRotator</a></div><br><div class="navLinks"><a href=MVector.html>MVector</a></div><br><div class="navLinks"><a href=Math.html>Math</a></div><br><div class="navLinks"><a href=Math.Magic.html>Math.Magic</a></div><br><div class="navLinks"><a href=Pathfinding.html>Pathfinding</a></div><br><div class="navLinks"><a href=SubSystems.GameData.html>SubSystems.GameData</a></div><br><div class="navLinks"><a href=THeap.html>THeap</a></div><br><div class="navLinks"><a href=TPair2.html>TPair2</a></div><br><div class="navLinks"><a href=TTriple3.html>TTriple3</a></div><br><div class="navLinks"><a href=Utils.html>Utils</a></div><br></div><br><br><div style="display: table-cell;"><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>public class : MonoBehaviour </pre></pre><h1 class="classHead C">DynamicPathfinding</h1><br><p class="simplePara C">Dynamic Pathfinding that adapts to the world environment.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public bool </pre><p class="basicHead">bDrawGizmos</p><p class="simplePara">Draw the Pathfinding bounding box.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public bool </pre><p class="basicHead">GizmoOptions</p><p class="simplePara">Draw the positions of the individual nodes.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] Vector3 </pre><p class="basicHead">LocalCentre</p><p class="simplePara">The local centre of the bounding box.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] Vector3Int </pre><p class="basicHead">Bounds</p><p class="simplePara">The Width, Height, and Depth of the Pathfinding box.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] LayerMask </pre><p class="basicHead">TraversableLayer</p><p class="simplePara">The layer/s that can be walked on.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] [Min(1)] float </pre><p class="basicHead">PointsPerUnit</p><p class="simplePara">The number of Nodes per Unity-world unit.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] bool </pre><p class="basicHead">bAirIsTraversable</p><p class="simplePara">Make the Traversable Layer <not> traversable.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] bool </pre><p class="basicHead">bCheckInsideContacts</p><p class="simplePara">Whether or not to check if Nodes inside a contact is traversable.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] EInsideContactQueryMethod </pre><p class="basicHead">InsideContactMethod</p><p class="simplePara">The method to use to determine if a point is inside a Collider.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] bool </pre><p class="basicHead">bIsDynamic</p><p class="simplePara">True if this should adapt to the world environment.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] [Min(1)] int </pre><p class="basicHead">FramesBetweenUpdate</p><p class="simplePara">The number of frames between each dynamic update to the Pathfinding Nodes.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] [Min(1)] int </pre><p class="basicHead">NodesPerUpdate</p><p class="simplePara">The number of Nodes to update per frame.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MArray&lt;Node&gt; </pre><p class="basicHead">Nodes</p><p class="simplePara">The Nodes that are considered in the Dynamic Pathfinder.</p><p class="simplePara">The order is Z, Y, X.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public void </pre><h1 class="basicHead">PlotPoints ()</h1><p class="keyword">Summary:</p><p class="simplePara">Plot the Nodes, adhering to Bounds.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public void </pre><h1 class="basicHead">ForceReconnectAll ()</h1><p class="keyword">Summary:</p><p class="simplePara">Forces all Nodes to reconnect with each other.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public bool </pre><h1 class="basicHead">Pathfind (Node Origin, Node Destination, MArray&lt;Node&gt;&  Path)</h1><p class="keyword">Summary:</p><p class="simplePara">Find the shortest path from Origin to Destination.</p><p class="keyword">Params:</p><p class="ParamName">Origin: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Node to begin searching on.</p><p class="ParamName">Destination: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Node to reach.</p><p class="ParamName">Path: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The shortest path from Origin to Destination.</p><p class="keyword">Returns:</p><p class="simplePara">True if a path from Origin to Destination was found.</p><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>public enum EInsideContactQueryMethod : byte </pre></pre><h1 class="classHead C">EInsideContactQueryMethod</h1><br><p class="simplePara C">The method for checking if a point is inside a Collider.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><p class="basicHead">Raycast</p><p class="simplePara">Raycast from Contact Point to Collider Centre.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><p class="basicHead">Bounds</p><p class="simplePara">Use Collider Bounds to Contact Point Check.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><p class="basicHead">RaycastAndBounds</p><p class="simplePara">Use both Raycast and Bounds checks.</p><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>public class Node : MNode, IHeapItem&lt;Node&gt; </pre></pre><h1 class="classHead C">Node</h1><br><p class="simplePara C">A sample Node class for Pathfinding.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><h1 class="basicHead">Push (Node N)</h1><p class="keyword">Summary:</p><p class="simplePara">Registers N as a neighbour, and this as N's neighbour.</p><p class="keyword">Params:</p><p class="ParamName">N: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Neighbour.</p><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>public interface &lt;T&gt; where T : IComparable&lt;T&gt; </pre></pre><h1 class="classHead C">INode</h1><br><p class="simplePara C">The Interface that T must implement if it is to be used by Pathfinding.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>float </pre><p class="basicHead">F</p><p class="simplePara">This Node's F score.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>float </pre><p class="basicHead">G</p><p class="simplePara">This Node's G score.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>float </pre><p class="basicHead">H</p><p class="simplePara">This Node's H score.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>uint </pre><h1 class="basicHead">NumberOfDirections ()</h1><p class="keyword">Summary:</p><p class="simplePara">How many directions can this Node point to?</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>bool </pre><h1 class="basicHead">IsTraversable ()</h1><p class="keyword">Summary:</p><p class="simplePara">Is this block traversable?</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>INode&lt;T&gt; </pre><h1 class="basicHead">Neighbour (int Direction)</h1><p class="keyword">Summary:</p><p class="simplePara">Get the Neighbouring Node at Direction.</p><p class="keyword">Params:</p><p class="ParamName">Direction: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The neighbour of this Node in this direction.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>float </pre><h1 class="basicHead">DistanceHeuristic (T RelativeTo)</h1><p class="keyword">Summary:</p><p class="simplePara">The distance heuristic to calculate pathfinding scores.</p><p class="keyword">Params:</p><p class="ParamName">RelativeTo: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distance to from this T to Relative To.</p><p class="keyword">Returns:</p><p class="simplePara">An indicative distance from this T, Relative To.</p><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>public abstract class : INode&lt;MNode&gt;, IHeapItem&lt;MNode&gt; </pre></pre><h1 class="classHead C">MNode</h1><br><p class="simplePara C">Base class for Nodes to be use in A* Pathfinding.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><p class="basicHead">bIsTraversable</p><p class="simplePara">Is this Node an obstacle for Pathfinding?</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><p class="basicHead">Neighbours</p><p class="simplePara">The connected Nodes to this Node.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public abstract float </pre><h1 class="basicHead">DistanceHeuristic (MNode RelativeTo)</h1><p class="keyword">Summary:</p><p class="simplePara">The distance heuristic to calculate pathfinding scores.</p><p class="keyword">Params:</p><p class="ParamName">RelativeTo: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distance to from this T to Relative To.</p><p class="keyword">Returns:</p><p class="simplePara">An indicative distance from this T, Relative To.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public abstract bool </pre><h1 class="basicHead">IsTraversable ()</h1><p class="keyword">Summary:</p><p class="simplePara">Is this block traversable?</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>INode&lt;MNode&gt; </pre><h1 class="basicHead">Neighbour (int Direction)</h1><p class="keyword">Summary:</p><p class="simplePara">Get the Neighbouring Node at Direction.</p><p class="keyword">Params:</p><p class="ParamName">Direction: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The neighbour of this Node in this direction.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public virtual int </pre><h1 class="basicHead">NumberOfDirections ()</h1><p class="keyword">Summary:</p><p class="simplePara">How many directions can this Node point to?</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><h1 class="basicHead">MNode -> Boolean ()</h1><p class="keyword">Summary:</p><p class="simplePara">Is MNode M null?</p><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>public class &lt;T&gt; : MonoBehaviour where T : INode&lt;T&gt;, IHeapItem&lt;T&gt; </pre></pre><h1 class="classHead C">MPathManager</h1><br><p class="simplePara C">The MonoBehavior script that manages pathfinding over frames.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] [Min(1)] uint </pre><p class="basicHead">ComputationsPerFrame</p><p class="simplePara">The number of paths to compute per frame.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>[SerializeField] [Min(1)] uint </pre><p class="basicHead">FramesBetweenComputations</p><p class="simplePara">The number of frames between computing path/s.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public void </pre><h1 class="basicHead">Pause ()</h1><p class="keyword">Summary:</p><p class="simplePara">Temporarily stop the computation of paths.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public void </pre><h1 class="basicHead">Resume ()</h1><p class="keyword">Summary:</p><p class="simplePara">Continue the computation of paths.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public EStatus </pre><h1 class="basicHead">Status ()</h1><p class="keyword">Summary:</p><p class="simplePara">Prints the current status of this Path Manager.</p><p class="keyword">Returns:</p><p class="simplePara">If this Path Manager is currently Paused, or Running.</p><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>public static class &lt;T&gt; where T : MNode, IHeapItem&lt;T&gt; </pre></pre><h1 class="classHead C">Pathfinding</h1><br><p class="simplePara C">Provides the A* Pathfinding implementation for T.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static bool </pre><h1 class="basicHead">AStar (T Origin, Y Destination, MArray&lt;T&gt;&  Path, UInt32 Depth, UInt32 MapSize, bool bUseDiagnostics)</h1><p class="keyword">Summary:</p><p class="simplePara">A* pathfinds from Origin to Destination looking uDepth times within a uMapSize.</p><p class="keyword">Params:</p><p class="ParamName">Origin: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T position to begin pathfinding.</p><p class="ParamName">Destination: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T position to pathfind to.</p><p class="ParamName">Path: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reference T List of that make up the path from Origin to Destination.</p><p class="ParamName">Depth: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The depth to search to.</p><p class="ParamName">MapSize: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The total size of the map to be traversed. (The number of INodes).</p><p class="ParamName">bUseDiagnostics: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time the duration of Pathfinding?</p><p class="keyword">Returns:</p><p class="simplePara">Whether or not a path was found from Origin to Destination within uDepth in uMapSize.</p><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>public static class &lt;T&gt; where T : INode&lt;T&gt;, IHeapItem&lt;T&gt; </pre></pre><h1 class="classHead C">PathRegister</h1><br><p class="simplePara C">Computes a number of paths over a number of frames.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static void </pre><h1 class="basicHead">RequestPath (T Origin, Y Destination, Action&lt;System.Collections.Generic.List{ OnPathCalculated, Action&lt;System.Collections.Generic.List{ OnPathFailed)</h1><p class="keyword">Summary:</p><p class="simplePara">Register a path to compute when possible.</p><p class="keyword">Remarks:</p><p class="simplePara">This is on a first-in, first-out basis. A Queue.</p><p class="keyword">Params:</p><p class="ParamName">Origin: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T position to begin pathfinding.</p><p class="ParamName">Destination: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T position to pathfind to.</p><p class="ParamName">OnPathCalculated: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What to do when a path is found? List of T pathway.</p><p class="ParamName">OnPathFailed: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;What to do when a path cannot be found? List of T pathway attempt.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static bool </pre><h1 class="basicHead">ComputeNext ()</h1><p class="keyword">Summary:</p><p class="simplePara">Computes the next path in FIFO.</p><p class="keyword">Returns:</p><p class="simplePara">Whether or not a computation was executed.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static void </pre><h1 class="basicHead">ComputeBatch (UInt32 BatchSize)</h1><p class="keyword">Summary:</p><p class="simplePara">Computes BatchSize paths in a single call.</p><p class="keyword">Params:</p><p class="ParamName">BatchSize: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of paths to compute.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static uint </pre><h1 class="basicHead">GetPathQueueSize ()</h1><p class="keyword">Summary:</p><p class="simplePara">Gets the number of agents waiting to compute paths.</p><p class="keyword">Returns:</p><p class="simplePara">Unsigned integer number of T's awaiting a path.</p></div></div></div></body></html>