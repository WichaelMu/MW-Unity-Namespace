<!DOCTYPE html><html lang=en><head><title>Home | MICHAEL WU</title><link rel=stylesheet href=MWUnityNamespace.css><meta charset=UTF-8></head><body><div class=header id=top>MW UNITY NAMESPACE</div><div style="width: 100%; display: table;"><div style="display: table-row"><div style="width: 200px; display: table-cell;"><div class="navLinks"><a href=Audio.html>Audio</a></div><br><div class="navLinks"><a href=Behaviour.html>Behaviour</a></div><br><div class="navLinks"><a href=CameraUtils.html>CameraUtils</a></div><br><div class="navLinks"><a href=Conversion.html>Conversion</a></div><br><div class="navLinks"><a href=Diagnostics.html>Diagnostics</a></div><br><div class="navLinks"><a href=EButton.html>EButton</a></div><br><div class="navLinks"><a href=EDirection.html>EDirection</a></div><br><div class="navLinks"><a href=EEquation.html>EEquation</a></div><br><div class="navLinks"><a href=EUnit.html>EUnit</a></div><br><div class="navLinks"><a href=Easing.html>Easing</a></div><br><div class="navLinks"><a href=HUD.html>HUD</a></div><br><div class="navLinks"><a href=IHeapItem.html>IHeapItem</a></div><br><div class="navLinks"><a href=IO.html>IO</a></div><br><div class="navLinks"><a href=Kinetic.html>Kinetic</a></div><br><div class="navLinks"><a href=MArray.html>MArray</a></div><br><div class="navLinks"><a href=MRotator.html>MRotator</a></div><br><div class="navLinks"><a href=MVector.html>MVector</a></div><br><div class="navLinks"><a href=Math.html>Math</a></div><br><div class="navLinks"><a href=Pathfinding.html>Pathfinding</a></div><br><div class="navLinks"><a href=THeap.html>THeap</a></div><br><div class="navLinks"><a href=TPair2.html>TPair2</a></div><br><div class="navLinks"><a href=TTriple3.html>TTriple3</a></div><br><div class="navLinks"><a href=Utils.html>Utils</a></div><br></div><br><br><div style="display: table-cell;"><br><br><h1 class="classHead C">Utils</h1><br><p class="simplePara C">Helper Variables and Functions.</p><p class="basicHead">kThousandth</p><br><p class="simplePara">Shorthand for writing / 1000. (Always faster to multiply than to divide)</p><p class="basicHead">kHundreth</p><br><p class="simplePara">Shorthand for writing / 100. (Always faster to multiply than to divide)</p><p class="basicHead">k0Percent</p><br><p class="simplePara">Shorthand for writing / 10. (Always faster to multiply than to divide)</p><p class="basicHead">kQuarter</p><br><p class="simplePara">Shorthand for writing / 4. (Always faster to multiply than to divide)</p><p class="basicHead">kHalf</p><br><p class="simplePara">Shorthand for writing / 2. (Always faster to multiply than to divide)</p><p class="basicHead">kOneThird</p><br><p class="simplePara">Shorthand for writing / 3. (Always faster to multiply than to divide)</p><p class="basicHead">kTwoThirds</p><br><p class="simplePara">Shorthand for writing 1.6 recurring. (Always faster to multiply than to divide)</p><p class="basicHead">kPhi</p><br><p class="simplePara">The golden ratio.</p><p class="basicHead">kE</p><br><p class="simplePara">Euler's number. (e)</p><p class="basicHead">kSqrt2</p><br><p class="simplePara">Shorthand for writing UnityEngine.Mathf.Sqrt(2). (Always faster to multiply than to divide)</p><p class="basicHead">kSqrt3</p><br><p class="simplePara">Shorthand for writing UnityEngine.Mathf.Sqrt(3). (Always faster to multiply than to divide)</p><p class="basicHead">kInversePI</p><br><p class="simplePara">Shorthand for writing 1 / Mathf.PI.</p><p class="basicHead">kHalfPI</p><br><p class="simplePara">Shorthand for writing Mathf.PI * kHalf.</p><p class="basicHead">kTo255RGB</p><br><p class="simplePara">The ratio between 1 and 255.</p><h1 class="basicHead">InFOV (EDirection dirFace, Transform ASelf, Transform ATarget, float fSearchAngle)</h1><br><p class="keyword">Summary:</p><p class="simplePara">If self can see Transform target within SearchAngle degrees while facing EDirection.</p><p class="keyword">Params:</p><p class="simplePara">dirFace: The EDirection self is facing.</p><p class="simplePara">ASelf: The Transform searching for target.</p><p class="simplePara">ATarget: The Transform to look out for.</p><p class="simplePara">fSearchAngle: The maximum degrees to search for target.</p><h1 class="basicHead">InFOV (EDirection dirFace, Transform ASelf, Vector3 vTarget, float fSearchAngle)</h1><br><p class="keyword">Summary:</p><p class="simplePara">If self can see Transform target within SearchAngle degrees while facing EDirection.</p><p class="keyword">Params:</p><p class="simplePara">dirFace: The EDirection self is facing.</p><p class="simplePara">ASelf: The Transform searching for target.</p><p class="simplePara">vTarget: The Vector3 position to look out for.</p><p class="simplePara">fSearchAngle: The maximum degrees to search for target.</p><h1 class="basicHead">LineOfSight (Vector3 vSelf, Vector3 vTo, LayerMask lmObstacles)</h1><br><p class="keyword">Summary:</p><p class="simplePara">If self has an unobstructed line of sight to to.</p><p class="keyword">Params:</p><p class="simplePara">vSelf: The Vector3 position to look from.</p><p class="simplePara">vTo: The Vector3 position to look to.</p><p class="simplePara">lmObstacles: The LayerMask obstacles to consider obtrusive.</p><h1 class="basicHead">LineOfSight (Vector3 vSelf, Vector3 vTo)</h1><br><p class="keyword">Summary:</p><p class="simplePara">If Vector3 self has an unobstructed line of sight to to.</p><p class="keyword">Params:</p><p class="simplePara">vSelf: The Vector3 position to look from.</p><p class="simplePara">vTo: The Vector3 position to look to.</p><h1 class="basicHead">RoundToDP (float fValue, int nDP)</h1><br><p class="keyword">Summary:</p><p class="simplePara">The fValue rounded to dp decimal places.</p><p class="keyword">Params:</p><p class="simplePara">fValue: The value to be rounded.</p><p class="simplePara">nDP: The decimal places to be included.</p><h1 class="basicHead">FlipFlop (Boolean&  bBool)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Flip-Flops Bool.</p><h1 class="basicHead">FlipFlop (Boolean&  bBool, Action ACallbackTrue, Action ACallbackFalse)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Flip-Flops Bool.</p><p class="simplePara">ACallbackTrue: The method to call if the flip-flop is true.</p><p class="simplePara">ACallbackFalse: The method to call if the flip-flop is false.</p><h1 class="basicHead">IsWithin (float fValue, float fFrom, float fLimit)</h1><br><p class="keyword">Summary:</p><p class="simplePara">If value is within the +- limit of from.</p><p class="keyword">Params:</p><p class="simplePara">fValue: The value to check.</p><p class="simplePara">fFrom: The value to compare.</p><p class="simplePara">fLimit: The limits to consider.</p><h1 class="basicHead">Max (Vector3 vL, Vector3 vR)</h1><br><p class="keyword">Summary:</p><p class="simplePara">The largest Vector3 between L and R, according to Vector3.magnitude.</p><h1 class="basicHead">Min (Vector3 vL, Vector3 vR)</h1><br><p class="keyword">Summary:</p><p class="simplePara">The smallest Vector3 between L and R, according to Vector3.magnitude.</p><h1 class="basicHead">Fibonacci (int n)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Returns the n'th Fibonacci number.</p><h1 class="basicHead">GenerateEqualSphere (int nResolution, float fGoldenRationModifier)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Generates spherical points with an equal distribution.</p><p class="keyword">Params:</p><p class="simplePara">nResolution: The number of points to generate.</p><p class="simplePara">fGoldenRationModifier: Adjusts the golden ratio.</p><p class="keyword">Returns:</p><p class="simplePara">The Vector3[] points for the sphere.</p><h1 class="basicHead">Bridge (Vector3 vOrigin, Vector3 vTarget, int nResolution, float fHeight)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Generates the points to 'bridge' origin and target together at a height as an arc.</p><p class="keyword">Params:</p><p class="simplePara">vOrigin: The Vector3 starting point of the bridge.</p><p class="simplePara">vTarget: The Vector3 ending point of the bridge.</p><p class="simplePara">nResolution: The number of points for the bridge.</p><p class="simplePara">fHeight: The maximum height of the bridge.</p><p class="keyword">Returns:</p><p class="simplePara">The Vector3[] points for the bridge.</p><h1 class="basicHead">MirrorNumber (float Number, float Minimum, float Maximum)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Mirrors Number about Minimum and Maximum, inclusive.</p><p class="keyword">Params:</p><p class="simplePara">Number: The number to anchor a reflection.</p><p class="simplePara">Minimum: The minimum number that can be reflected.</p><p class="simplePara">Maximum: The maximum number that can be reflected.</p><p class="keyword">Returns:</p><p class="simplePara">The reflected number.</p><h1 class="basicHead">MirrorNumber (int Number, int Minimum, int Maximum)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Mirrors Number about Minimum and Maximum, inclusive. Not to be confused with MArray{T}.Mirror(int, int).</p><p class="keyword">Params:</p><p class="simplePara">Number: The number to anchor a reflection.</p><p class="simplePara">Minimum: The minimum number that can be reflected.</p><p class="simplePara">Maximum: The maximum number that can be reflected.</p><p class="keyword">Returns:</p><p class="simplePara">The reflected number.</p></div></div></div></body></html>