<!DOCTYPE html><html lang=en><head><title>Home | MICHAEL WU</title><link rel=stylesheet href=MWUnityNamespace.css><meta charset=UTF-8></head><body><div class=header id=top>MW UNITY NAMESPACE</div><div style="width: 100%; display: table;"><div style="display: table-row"><div style="width: 200px; display: table-cell;"><div class="navLinks"><a href=Audio.html>Audio</a></div><br><div class="navLinks"><a href=Behaviour.html>Behaviour</a></div><br><div class="navLinks"><a href=CameraUtils.html>CameraUtils</a></div><br><div class="navLinks"><a href=Conversion.html>Conversion</a></div><br><div class="navLinks"><a href=Core.html>Core</a></div><br><div class="navLinks"><a href=Diagnostics.html>Diagnostics</a></div><br><div class="navLinks"><a href=Easing.html>Easing</a></div><br><div class="navLinks"><a href=Editor.html>Editor</a></div><br><div class="navLinks"><a href=Enums.html>Enums</a></div><br><div class="navLinks"><a href=HUD.html>HUD</a></div><br><div class="navLinks"><a href=IO.html>IO</a></div><br><div class="navLinks"><a href=Kinetic.html>Kinetic</a></div><br><div class="navLinks"><a href=MArray.html>MArray</a></div><br><div class="navLinks"><a href=Math.html>Math</a></div><br><div class="navLinks"><a href=Pathfinding.html>Pathfinding</a></div><br><div class="navLinks"><a href=Vector.html>Vector</a></div><br></div><br><br><div style="display: table-cell;"><br><br><h1 class="classHead C">THeap</h1><br><p class="simplePara C">The implementation of a Minimum or Maximum Heap.</p><p class="basicHead">Count</p><br><p class="simplePara">The number of elements in the heap.</p><h1 class="basicHead">CONSTRUCTOR (UInt2 uMaxSize)</h1><br><p class="simplePara">Generates a new Heap, initialised with uMaxSize.</p><h1 class="basicHead">Add (T TItem)</h1><br><p class="simplePara">Adds an item to this Heap.</p><p class="simplePara">TItem: The item to add.</p><h1 class="basicHead">RemoveFirst ()</h1><br><p class="simplePara">Remove the element at the root of this Heap.</p><h1 class="basicHead">UpdateItem (T TItem)</h1><br><p class="simplePara">Updates Item's position in the Heap.</p><p class="simplePara">TItem: The item to update.</p><h1 class="basicHead">UpdateItemUp (T TItem)</h1><br><p class="simplePara">Sorts this Item upawrds.</p><p class="simplePara">TItem: The item to update.</p><h1 class="basicHead">UpdateItemDown (T TItem)</h1><br><p class="simplePara">Sorts this Item downwards.</p><p class="simplePara">TItem: The item to update.</p><h1 class="basicHead">Contains (T TItem)</h1><br><p class="simplePara">Whether or not this Heap contains Item.</p><p class="simplePara">TItem: The Item to check.</p><br><br><h1 class="classHead C">IHeapItem</h1><br><p class="simplePara C">The Interface that T must implement if it is to be used as a Heap.</p><p class="basicHead">HeapItemIndex</p><br><p class="simplePara">The position in a THeap.</p><br><br><h1 class="classHead C">TPair&lt;T&gt;&lt;Y&gt;2</h1><br><p class="simplePara C">Generates a new pair of two types of values.</p><p class="basicHead">First</p><br><p class="simplePara">The first element in this pair.</p><p class="basicHead">Second</p><br><p class="simplePara">The second element in this pair.</p><h1 class="basicHead">CONSTRUCTOR (T First, Y Second)</h1><br><p class="simplePara">Constructs a Pair with two generics.</p><h1 class="basicHead">GetHashCode ()</h1><br><p class="simplePara">A combined Hash Code with First and Second.</p><br><br><h1 class="classHead C">TTriple</h1><br><p class="simplePara C">Generates a new variable of three types of values.</p><p class="basicHead">First</p><br><p class="simplePara">The first element in this pair.</p><p class="basicHead">Second</p><br><p class="simplePara">The second element in this pair.</p><p class="basicHead">Third</p><br><p class="simplePara">The third element in this pair.</p><h1 class="basicHead">CONSTRUCTOR (T First, Y Second, T&lt;T&gt;&lt;Y&gt;2 Third)</h1><br><p class="simplePara">Constructs a Triple with three generics.</p><h1 class="basicHead">GetHashCode ()</h1><br><p class="simplePara">A combined Hash Code with First, Second and Third.</p><br><br><h1 class="classHead C">Utils</h1><br><p class="simplePara C">Helper Variables and Functions.</p><p class="basicHead">kThousandth</p><br><p class="simplePara">Shorthand for writing / 1000. (Always faster to multiply than to divide)</p><p class="basicHead">kHundreth</p><br><p class="simplePara">Shorthand for writing / 100. (Always faster to multiply than to divide)</p><p class="basicHead">k0Percent</p><br><p class="simplePara">Shorthand for writing / 10. (Always faster to multiply than to divide)</p><p class="basicHead">kQuarter</p><br><p class="simplePara">Shorthand for writing / 4. (Always faster to multiply than to divide)</p><p class="basicHead">kHalf</p><br><p class="simplePara">Shorthand for writing / 2. (Always faster to multiply than to divide)</p><p class="basicHead">kOneThird</p><br><p class="simplePara">Shorthand for writing / 3. (Always faster to multiply than to divide)</p><p class="basicHead">kTwoThirds</p><br><p class="simplePara">Shorthand for writing 1.6 recurring. (Always faster to multiply than to divide)</p><p class="basicHead">kPhi</p><br><p class="simplePara">The golden ratio.</p><p class="basicHead">kE</p><br><p class="simplePara">Euler's number. (e)</p><p class="basicHead">kSqrt2</p><br><p class="simplePara">Shorthand for writing UnityEngine.Mathf.Sqrt(2). (Always faster to multiply than to divide)</p><p class="basicHead">kSqrt</p><br><p class="simplePara">Shorthand for writing UnityEngine.Mathf.Sqrt(3). (Always faster to multiply than to divide)</p><p class="basicHead">kInversePI</p><br><p class="simplePara">Shorthand for writing 1 / Mathf.PI.</p><p class="basicHead">kHalfPI</p><br><p class="simplePara">Shorthand for writing Mathf.PI * kHalf.</p><p class="basicHead">kTo255RGB</p><br><p class="simplePara">The ratio between 1 and 255.</p><h1 class="basicHead">InFOV (EDirection dirFace, Transform ASelf, Transform ATarget, float fSearchAngle)</h1><br><p class="simplePara">If self can see Transform target within SearchAngle degrees while facing EDirection.</p><p class="simplePara">dirFace: The EDirection self is facing.</p><p class="simplePara">ASelf: The Transform searching for target.</p><p class="simplePara">ATarget: The Transform to look out for.</p><p class="simplePara">fSearchAngle: The maximum degrees to search for target.</p><h1 class="basicHead">InFOV (EDirection dirFace, Transform ASelf, Vector vTarget, float fSearchAngle)</h1><br><p class="simplePara">If self can see Transform target within SearchAngle degrees while facing EDirection.</p><p class="simplePara">dirFace: The EDirection self is facing.</p><p class="simplePara">ASelf: The Transform searching for target.</p><p class="simplePara">vTarget: The Vector3 position to look out for.</p><p class="simplePara">fSearchAngle: The maximum degrees to search for target.</p><h1 class="basicHead">LineOfSight (Vector vSelf, Vector vTo, LayerMask lmObstacles)</h1><br><p class="simplePara">If self has an unobstructed line of sight to to.</p><p class="simplePara">vSelf: The Vector3 position to look from.</p><p class="simplePara">vTo: The Vector3 position to look to.</p><p class="simplePara">lmObstacles: The LayerMask obstacles to consider obtrusive.</p><h1 class="basicHead">LineOfSight (Vector vSelf, Vector vTo)</h1><br><p class="simplePara">If Vector3 self has an unobstructed line of sight to to.</p><p class="simplePara">vSelf: The Vector3 position to look from.</p><p class="simplePara">vTo: The Vector3 position to look to.</p><h1 class="basicHead">RoundToDP (float fValue, Int2 nDP)</h1><br><p class="simplePara">The fValue rounded to dp decimal places.</p><p class="simplePara">fValue: The value to be rounded.</p><p class="simplePara">nDP: The decimal places to be included.</p><h1 class="basicHead">FlipFlop (Boolean&  bBool)</h1><br><p class="simplePara">Flip-Flops Bool.</p><h1 class="basicHead">FlipFlop (Boolean&  bBool, Action ACallbackTrue, Action ACallbackFalse)</h1><br><p class="simplePara">Flip-Flops Bool.</p><p class="simplePara">ACallbackTrue: The method to call if the flip-flop is true.</p><p class="simplePara">ACallbackFalse: The method to call if the flip-flop is false.</p><h1 class="basicHead">IsWithin (float fValue, float fFrom, float fLimit)</h1><br><p class="simplePara">If value is within the +- limit of from.</p><p class="simplePara">fValue: The value to check.</p><p class="simplePara">fFrom: The value to compare.</p><p class="simplePara">fLimit: The limits to consider.</p><h1 class="basicHead">Max (Vector vL, Vector vR)</h1><br><p class="simplePara">The largest Vector3 between L and R, according to Vector3.magnitude.</p><h1 class="basicHead">Min (Vector vL, Vector vR)</h1><br><p class="simplePara">The smallest Vector3 between L and R, according to Vector3.magnitude.</p><h1 class="basicHead">Fibonacci (Int2 n)</h1><br><p class="simplePara">Returns the n'th Fibonacci number.</p><h1 class="basicHead">GenerateEqualSphere (Int2 nResolution, float fGoldenRationModifier)</h1><br><p class="simplePara">Generates spherical points with an equal distribution.</p><p class="simplePara">nResolution: The number of points to generate.</p><p class="simplePara">fGoldenRationModifier: Adjusts the golden ratio.</p><h1 class="basicHead">Bridge (Vector vOrigin, Vector vTarget, Int2 nResolution, float fHeight)</h1><br><p class="simplePara">Generates the points to 'bridge' origin and target together at a height as an arc.</p><p class="simplePara">vOrigin: The Vector3 starting point of the bridge.</p><p class="simplePara">vTarget: The Vector3 ending point of the bridge.</p><p class="simplePara">nResolution: The number of points for the bridge.</p><p class="simplePara">fHeight: The maximum height of the bridge.</p><h1 class="basicHead">MirrorNumber (float Number, float Minimum, float Maximum)</h1><br><p class="simplePara">Mirrors Number about Minimum and Maximum, inclusive.</p><p class="simplePara">Number: The number to anchor a reflection.</p><p class="simplePara">Minimum: The minimum number that can be reflected.</p><p class="simplePara">Maximum: The maximum number that can be reflected.</p><h1 class="basicHead">MirrorNumber (Int2 Number, Int2 Minimum, Int2 Maximum)</h1><br><p class="simplePara">Mirrors Number about Minimum and Maximum, inclusive. Not to be confused with MArray{T}.Mirror(int, int).</p><p class="simplePara">Number: The number to anchor a reflection.</p><p class="simplePara">Minimum: The minimum number that can be reflected.</p><p class="simplePara">Maximum: The maximum number that can be reflected.</p></div></div></div></body></html>