<!DOCTYPE html><html lang=en><head><title>MVector | MW Unity Namespace</title><link rel=stylesheet href=CSS/MWUnityNamespace.css><meta charset=UTF-8></head><body><div class=header id=top>MW UNITY NAMESPACE</div><div style="width: 100%; display: table;"><div style="display: table-row"><div style="width: 200px; display: table-cell;"><div class="navLinks"><a href=Audio.html>Audio</a></div><br><div class="navLinks"><a href=Behaviour.html>Behaviour</a></div><br><div class="navLinks"><a href=CameraUtils.html>CameraUtils</a></div><br><div class="navLinks"><a href=Conversion.html>Conversion</a></div><br><div class="navLinks"><a href=Diagnostics.html>Diagnostics</a></div><br><div class="navLinks"><a href=EButton.html>EButton</a></div><br><div class="navLinks"><a href=EComponentAxis.html>EComponentAxis</a></div><br><div class="navLinks"><a href=EDirection.html>EDirection</a></div><br><div class="navLinks"><a href=EEquation.html>EEquation</a></div><br><div class="navLinks"><a href=EUnit.html>EUnit</a></div><br><div class="navLinks"><a href=Easing.html>Easing</a></div><br><div class="navLinks"><a href=Extensions.html>Extensions</a></div><br><div class="navLinks"><a href=HUD.html>HUD</a></div><br><div class="navLinks"><a href=HUD.Line.html>HUD.Line</a></div><br><div class="navLinks"><a href=HUD.UI.html>HUD.UI</a></div><br><div class="navLinks"><a href=IHeapItem.html>IHeapItem</a></div><br><div class="navLinks"><a href=IO.html>IO</a></div><br><div class="navLinks"><a href=Kinetic.html>Kinetic</a></div><br><div class="navLinks"><a href=MArray.html>MArray</a></div><br><div class="navLinks"><a href=MRotator.html>MRotator</a></div><br><div class="navLinks"><a href=MVector.html>MVector</a></div><br><div class="navLinks"><a href=Math.html>Math</a></div><br><div class="navLinks"><a href=Math.Magic.html>Math.Magic</a></div><br><div class="navLinks"><a href=Pathfinding.html>Pathfinding</a></div><br><div class="navLinks"><a href=THeap.html>THeap</a></div><br><div class="navLinks"><a href=TPair2.html>TPair2</a></div><br><div class="navLinks"><a href=TTriple3.html>TTriple3</a></div><br><div class="navLinks"><a href=Utils.html>Utils</a></div><br></div><br><br><div style="display: table-cell;"><pre class="C" style="padding-right:25%;color:rgb(40,255,120);"><br>[Serializable] public partial struct </pre></pre><h1 class="classHead C">MVector</h1><br><p class="simplePara C">Vector representation of coordinates and points with three-dimensions.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public const float </pre><p class="basicHead">kEpsilon</p><p class="simplePara">Vector floating-point precision.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public unsafe float* </pre><p class="basicHead">pX</p><p class="simplePara">A pointer to the X-Axis.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public unsafe float* </pre><p class="basicHead">pY</p><p class="simplePara">A pointer to the Y-Axis.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public unsafe float* </pre><p class="basicHead">pZ</p><p class="simplePara">A pointer to the Z-Axis.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public readonly MVector </pre><p class="basicHead">YZ</p><p class="simplePara">A new MVector ignoring the X component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public readonly MVector </pre><p class="basicHead">XZ</p><p class="simplePara">A new MVector ignoring the Y component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public readonly MVector </pre><p class="basicHead">XY</p><p class="simplePara">A new MVector ignoring the Z component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><h1 class="basicHead">CONSTRUCTOR (float U)</h1><p class="keyword">Summary:</p><p class="simplePara">Construct all components to U.</p><p class="keyword">Params:</p><p class="ParamName">U: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uniform component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><h1 class="basicHead">CONSTRUCTOR (float X, float Y)</h1><p class="keyword">Summary:</p><p class="simplePara">Construct with X and Y components only.</p><p class="keyword">Params:</p><p class="ParamName">X: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X Component.</p><p class="ParamName">Y: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y Component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><h1 class="basicHead">CONSTRUCTOR (float X, float Y, float Z)</h1><p class="keyword">Summary:</p><p class="simplePara">Construct an MVector with X, Y, and Z components.</p><p class="keyword">Params:</p><p class="ParamName">X: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X Component.</p><p class="ParamName">Y: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y Component.</p><p class="ParamName">Z: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Z Component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"></pre><h1 class="basicHead">CONSTRUCTOR (Vector3 xyz)</h1><p class="keyword">Summary:</p><p class="simplePara">Construct an MVector with respect to a Vector3.</p><p class="keyword">Params:</p><p class="ParamName">xyz: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Vector3's Components to set this MVector.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static readonly MVector </pre><p class="basicHead">Zero</p><p class="simplePara">Short for writing MVector(0).</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static readonly MVector </pre><p class="basicHead">Right</p><p class="simplePara">Short for writing MVector(1, 0, 0).</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static readonly MVector </pre><p class="basicHead">Up</p><p class="simplePara">Short for writing MVector(0, 1, 0).</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static readonly MVector </pre><p class="basicHead">Forward</p><p class="simplePara">Short for writing MVector(0, 0, 1).</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static readonly MVector </pre><p class="basicHead">One</p><p class="simplePara">Short for writing MVector(1).</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static readonly MVector </pre><p class="basicHead">_2D</p><p class="simplePara">1 on XY components. 2D MVector Flag.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static readonly MVector </pre><p class="basicHead">_3D</p><p class="simplePara">1 on XZ components. 3D MVector Flag.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static readonly MVector </pre><p class="basicHead">NaN</p><p class="simplePara">NaN on all components.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static Vector3 </pre><h1 class="basicHead">V3 (MVector M)</h1><p class="keyword">Summary:</p><p class="simplePara">Converts an MVector to a Vector3.</p><p class="keyword">Params:</p><p class="ParamName">M: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector to convert.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector </pre><h1 class="basicHead">MV (Vector3 V)</h1><p class="keyword">Summary:</p><p class="simplePara">Converts a Vector3 to an MVector.</p><p class="keyword">Params:</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Vector3 to convert.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector </pre><h1 class="basicHead">Normalise ()</h1><p class="keyword">Summary:</p><p class="simplePara">Normalises V.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector </pre><h1 class="basicHead">Cross ()</h1><p class="keyword">Summary:</p><p class="simplePara">The vector cross ^ product of Left and Right.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static float </pre><h1 class="basicHead">Dot ()</h1><p class="keyword">Summary:</p><p class="simplePara">The vector dot | product of Left and Right.</p><p class="keyword">Remarks:</p><p class="simplePara">Does not assume Left and Right are normalised.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static bool </pre><h1 class="basicHead">Parallel (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">Whether left and right are Mathematics.Parallel(MVector, MVector, float) to each other.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector </pre><h1 class="basicHead">MVectorFromAngle (float Degrees, EDirection Forward)</h1><p class="keyword">Summary:</p><p class="simplePara">A normalised MVector at Degrees, relative to Forward.</p><p class="keyword">Params:</p><p class="ParamName">Degrees: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The angle offset.</p><p class="ParamName">Forward: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The forward direction.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static float </pre><h1 class="basicHead">Distance (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">The distance between Left and Right.</p><p class="keyword">Params:</p><p class="ParamName">Left: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Source of the distance.</p><p class="ParamName">Right: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Distance from source.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static float </pre><h1 class="basicHead">SqrDistance (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">Square Euclidean distance between Left and Right.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public float </pre><p class="basicHead">SqrMagnitude</p><p class="simplePara">The square magnitude of this MVector.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public float </pre><p class="basicHead">Magnitude</p><p class="simplePara">The magnitude of this MVector.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><p class="basicHead">Abs</p><p class="simplePara">The Mathf.Abs(float) of this MVector's components.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><p class="basicHead">Normalised</p><p class="simplePara">The normalised version of this MVector.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><h1 class="basicHead">Normalise ()</h1><p class="keyword">Summary:</p><p class="simplePara">Normalises this MVector.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public void </pre><h1 class="basicHead">Set ()</h1><p class="keyword">Summary:</p><p class="simplePara">Sets this MVector's components.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public bool </pre><h1 class="basicHead">IsNormalised ()</h1><p class="keyword">Summary:</p><p class="simplePara">Whether this MVector is a unit vector. (If this MVector is Mathematics.IsNormalised(MVector).</p><p class="keyword">Returns:</p><p class="simplePara">True if this MVector has a magnitude of one.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><h1 class="basicHead">Mirror (MVector Normal)</h1><p class="keyword">Summary:</p><p class="simplePara">This MVector's reflection among Normal.</p><p class="keyword">Params:</p><p class="ParamName">Normal: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The normal vector to mirror.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><h1 class="basicHead">RotateAngleAxis (float AngleDegrees, MVector Axis)</h1><p class="keyword">Summary:</p><p class="simplePara">Rotates this MVector at an angle of AngleDegrees around Axis.</p><p class="keyword">Params:</p><p class="ParamName">AngleDegrees: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The degrees at which to rotate this MVector.</p><p class="ParamName">Axis: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The axis to rotate this MVector around.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MRotator </pre><h1 class="basicHead">Rotation ()</h1><p class="keyword">Summary:</p><p class="simplePara">Converts a normalised vector to a Pitch, Yaw rotation.</p><p class="keyword">Remarks:</p><p class="simplePara">Roll is zero.</p><p class="keyword">Returns:</p><p class="simplePara">An MRotator defining the pitch and yaw of this direction vector.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public void </pre><h1 class="basicHead">DirectionAndLength (MVector&  Direction, float& Length)</h1><p class="keyword">Summary:</p><p class="simplePara">The direction and length of this MVector.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><h1 class="basicHead">Projection ()</h1><p class="keyword">Summary:</p><p class="simplePara">This MVector's projection.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><h1 class="basicHead">IgnoreX ()</h1><p class="keyword">Summary:</p><p class="simplePara">Ignores the X component of this MVector.</p><p class="keyword">Remarks:</p><p class="simplePara">Modifies this MVector.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector with a zeroed X component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><h1 class="basicHead">IgnoreY ()</h1><p class="keyword">Summary:</p><p class="simplePara">Ignores the Y component of this MVector.</p><p class="keyword">Remarks:</p><p class="simplePara">Modifies this MVector.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector with a zeroed Y component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><h1 class="basicHead">IgnoreZ ()</h1><p class="keyword">Summary:</p><p class="simplePara">Ignores the Z component of this MVector.</p><p class="keyword">Remarks:</p><p class="simplePara">Modifies this MVector.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector with a zeroed Z component.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public MVector </pre><h1 class="basicHead">Ignore (EComponentAxis Components)</h1><p class="keyword">Summary:</p><p class="simplePara">Ignores a set of Components on this MVector.</p><p class="keyword">Params:</p><p class="ParamName">Components: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The vector components to ignore.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector zeroed over Components.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public float </pre><h1 class="basicHead">Distance (MVector V)</h1><p class="keyword">Summary:</p><p class="simplePara">Euclidean distance between this MVector and another V.</p><p class="keyword">Params:</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector to find distance.</p><p class="keyword">Returns:</p><p class="simplePara">The Euclidean distance between this MVector and V.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public float </pre><h1 class="basicHead">SqrDistance (MVector V)</h1><p class="keyword">Summary:</p><p class="simplePara">The Euclidean distance, but without the square root calculation.</p><p class="keyword">Params:</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector to find square distance.</p><p class="keyword">Returns:</p><p class="simplePara">The square distance between this MVector and V.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator+ </pre><h1 class="basicHead">operator+ (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">Adds two MVectors together.</p><p class="keyword">Params:</p><p class="ParamName">Left: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left-side MVector.</p><p class="ParamName">Right: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right-side MVector.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, MVector Right) => new MVector(Left.X + Right.X, Left.Y + Right.Y, Left.Z + Right.Z)</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator+ </pre><h1 class="basicHead">operator+ (MVector Left, Vector3 Right)</h1><p class="keyword">Summary:</p><p class="simplePara">Adds a Vector3 to an MVector.</p><p class="keyword">Params:</p><p class="ParamName">Left: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector.</p><p class="ParamName">Right: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Vector3.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, Vector3 Right) => Left + (MVector)Right</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator+ </pre><h1 class="basicHead">operator+ (Vector3 Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">Adds an MVector to a Vector3.</p><p class="keyword">Params:</p><p class="ParamName">Left: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Vector3.</p><p class="ParamName">Right: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector.</p><p class="keyword">Returns:</p><p class="simplePara">(Vector3 Left, MVector Right) => (MVector)Left + Right</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator- </pre><h1 class="basicHead">operator- (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">Subtracts two MVectors.</p><p class="keyword">Params:</p><p class="ParamName">Left: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left-side MVector.</p><p class="ParamName">Right: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right-side MVector.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, MVector Right) => new MVector(Left.X - Right.X, Left.Y - Right.Y, Left.Z - Right.Z)</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator- </pre><h1 class="basicHead">operator- (MVector V)</h1><p class="keyword">Summary:</p><p class="simplePara">Negates an MVector.</p><p class="keyword">Params:</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector to negate all components.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector V) => V *= -1f</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator* </pre><h1 class="basicHead">operator* (float S, MVector V)</h1><p class="keyword">Summary:</p><p class="simplePara">Multiplies an MVector by a scalar on all components.</p><p class="keyword">Params:</p><p class="ParamName">S: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Scalar to multiply.</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector V, float S) => new MVector(V.X * S, V.Y * S, V.Z * S)</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator/ </pre><h1 class="basicHead">operator/ (MVector V, float D)</h1><p class="keyword">Summary:</p><p class="simplePara">Divides an MVector by a scalar on all components.</p><p class="keyword">Remarks:</p><p class="simplePara">If d == 0, this will throw a DivideByZeroException.</p><p class="keyword">Params:</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector.</p><p class="ParamName">D: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The denominator under all components.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector V, float D) => float S = 1 / D; return S * V</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator^ </pre><h1 class="basicHead">operator^ (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">The vector cross ^ product.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, MVector Right) => new MVector(Left.Y * Right.Z - Left.Z * Right.Y, Left.Z * Right.X - Left.X * Right.Z, Left.X * Right.Y - Left.Y * Right.X)</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static float operator| </pre><h1 class="basicHead">operator| (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">The vector dot | product.</p><p class="keyword">Remarks:</p><p class="simplePara">Does not assume Left and Right are normalised.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, MVector Right) => Left.X * Right.X + Left.Y * Right.Y + Left.Z * Right.Z</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator> </pre><h1 class="basicHead">operator&gt; (MVector From, MVector To)</h1><p class="keyword">Summary:</p><p class="simplePara">Normalised direction from to.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector From, MVector To) => (To - From).Normalised</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator< </pre><h1 class="basicHead">operator&lt; (MVector From, MVector To)</h1><p class="keyword">Summary:</p><p class="simplePara">Normalised direction from to.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector To, MVector From) => From > To</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator>> </pre><h1 class="basicHead">operator&gt;&gt; (MVector V, int I)</h1><p class="keyword">Summary:</p><p class="simplePara">Shifts all components to the right.</p><p class="keyword">Params:</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector to shift.</p><p class="ParamName">I: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of times to shift right.</p><p class="keyword">Returns:</p><p class="simplePara">X = Y, Y = Z, Z = X.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static MVector operator<< </pre><h1 class="basicHead">operator&lt;&lt (MVector V, int I)</h1><p class="keyword">Summary:</p><p class="simplePara">Shifts all components to the left.</p><p class="keyword">Params:</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The MVector to shift.</p><p class="ParamName">I: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The number of times to shift left.</p><p class="keyword">Returns:</p><p class="simplePara">X = Z, Y = X, Z = Y.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static bool operator== </pre><h1 class="basicHead">operator= (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">Compares two MVectors for equality.</p><p class="keyword">Params:</p><p class="ParamName">Left: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left-side comparison.</p><p class="ParamName">Right: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right-side comparison.</p><p class="keyword">Returns:</p><p class="simplePara">True if the square distance between Left and Right is less than kEpsilon ^ 2.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static bool operator!= </pre><h1 class="basicHead">operator!= (MVector Left, MVector Right)</h1><p class="keyword">Summary:</p><p class="simplePara">Compares two MVectors for inequality.</p><p class="keyword">Params:</p><p class="ParamName">Left: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left-side comparison.</p><p class="ParamName">Right: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right-side comparison.</p><p class="keyword">Returns:</p><p class="simplePara">The opposite of operator ==.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static implicit operator Vector3 </pre><h1 class="basicHead">MVector -> Vector3 ()</h1><p class="keyword">Summary:</p><p class="simplePara">Automatic conversion from an MVector to a Vector3.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static implicit operator Vector2 </pre><h1 class="basicHead">MVector -> Vector2 ()</h1><p class="keyword">Summary:</p><p class="simplePara">Automatic conversion from an MVector to a Vector2.</p><p class="keyword">Remarks:</p><p class="simplePara">Only the X and Y components are considered. The Z component is ignored.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static implicit operator MVector </pre><h1 class="basicHead">Vector3 -> MVector ()</h1><p class="keyword">Summary:</p><p class="simplePara">Automatic conversion from a Vector3 to an MVector.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static implicit operator MVector </pre><h1 class="basicHead">Vector2 -> MVector ()</h1><p class="keyword">Summary:</p><p class="simplePara">Automatic conversion from a Vector2 to an MVector.</p><p class="keyword">Remarks:</p><p class="simplePara">The resulting MVector will have a Z equal to zero.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static implicit operator Color </pre><h1 class="basicHead">MVector -> Color ()</h1><p class="keyword">Summary:</p><p class="simplePara">The Colour representation of this MVector, in 0-255 XYZ/RGB.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public override int </pre><h1 class="basicHead">GetHashCode ()</h1><p class="keyword">Summary:</p><p class="simplePara">Hash code for use in Maps, Sets, MArrays, etc.</p><p class="keyword">Returns:</p><p class="simplePara">GetHashCode() => X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2)</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public override string </pre><h1 class="basicHead">ToString ()</h1><p class="keyword">Summary:</p><p class="simplePara">A human-readable MVector.</p><p class="keyword">Returns:</p><p class="simplePara">ToString() => "X: " + X + " Y: " + Y + " Z: " + Z</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public string </pre><h1 class="basicHead">ToString (String Format)</h1><p class="keyword">Summary:</p><p class="simplePara">A human-readable MVector with formatting.</p><p class="keyword">Params:</p><p class="ParamName">Format: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The format to present float values.</p><p class="keyword">Returns:</p><p class="simplePara">A string with X, Y, and Z formatted according to Format.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public string </pre><h1 class="basicHead">ToString (String Format, IFormatProvider Provider)</h1><p class="keyword">Summary:</p><p class="simplePara">A human-readable MVector with formatting and a format provider.</p><p class="keyword">Params:</p><p class="ParamName">Format: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The format to present the float values.</p><p class="ParamName">Provider: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The format provider to present the float values.</p><p class="keyword">Returns:</p><p class="simplePara">A string with X, Y, and Z formatting according to Format and Provider.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public static unsafe MVector </pre><h1 class="basicHead">Clone (Vector3&  V)</h1><p class="keyword">Summary:</p><p class="simplePara">Copies the address of a Vector3's axes.</p><p class="keyword">Params:</p><p class="ParamName">V: </p><p class="ParamDesc">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Vector3 to copy.</p><p class="keyword">Returns:</p><p class="simplePara">A new MVector initialised with XYZ pointers only.</p><br><pre style="padding-right:25%;color:rgb(133, 245, 215);font-weight:549"><br>public unsafe MVector </pre><h1 class="basicHead">Dereference ()</h1><p class="keyword">Summary:</p><p class="simplePara">Dereferences pointers into XYZ coordinates.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector with dereferenced components.</p></div></div></div></body></html>