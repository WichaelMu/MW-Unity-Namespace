<!DOCTYPE html><html lang=en><head><title>Home | MICHAEL WU</title><link rel=stylesheet href=MWUnityNamespace.css><meta charset=UTF-8></head><body><div class=header id=top>MW UNITY NAMESPACE</div><div style="width: 100%; display: table;"><div style="display: table-row"><div style="width: 200px; display: table-cell;"><div class="navLinks"><a href=Audio.html>Audio</a></div><br><div class="navLinks"><a href=Behaviour.html>Behaviour</a></div><br><div class="navLinks"><a href=CameraUtils.html>CameraUtils</a></div><br><div class="navLinks"><a href=Conversion.html>Conversion</a></div><br><div class="navLinks"><a href=Diagnostics.html>Diagnostics</a></div><br><div class="navLinks"><a href=EButton.html>EButton</a></div><br><div class="navLinks"><a href=EComponentAxis.html>EComponentAxis</a></div><br><div class="navLinks"><a href=EDirection.html>EDirection</a></div><br><div class="navLinks"><a href=EEquation.html>EEquation</a></div><br><div class="navLinks"><a href=EUnit.html>EUnit</a></div><br><div class="navLinks"><a href=Easing.html>Easing</a></div><br><div class="navLinks"><a href=HUD.html>HUD</a></div><br><div class="navLinks"><a href=IHeapItem.html>IHeapItem</a></div><br><div class="navLinks"><a href=IO.html>IO</a></div><br><div class="navLinks"><a href=Kinetic.html>Kinetic</a></div><br><div class="navLinks"><a href=MArray.html>MArray</a></div><br><div class="navLinks"><a href=MRotator.html>MRotator</a></div><br><div class="navLinks"><a href=MVector.html>MVector</a></div><br><div class="navLinks"><a href=Math.html>Math</a></div><br><div class="navLinks"><a href=Pathfinding.html>Pathfinding</a></div><br><div class="navLinks"><a href=THeap.html>THeap</a></div><br><div class="navLinks"><a href=TPair2.html>TPair2</a></div><br><div class="navLinks"><a href=TTriple3.html>TTriple3</a></div><br><div class="navLinks"><a href=Utils.html>Utils</a></div><br></div><br><br><div style="display: table-cell;"><br><br><h1 class="classHead C">MVector</h1><br><p class="simplePara C">Vector representation of coordinates and points with three-dimensions.</p><p class="basicHead">kEpsilon</p><br><p class="simplePara">Vector floating-point precision.</p><p class="basicHead">YZ</p><br><p class="simplePara">A new MVector ignoring the X component.</p><p class="basicHead">XZ</p><br><p class="simplePara">A new MVector ignoring the Y component.</p><p class="basicHead">XY</p><br><p class="simplePara">A new MVector ignoring the Z component.</p><h1 class="basicHead">CONSTRUCTOR (float U)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Construct all components to U.</p><p class="keyword">Params:</p><p class="simplePara">U: Uniform component.</p><h1 class="basicHead">CONSTRUCTOR (float X, float Y)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Construct with X and Y components only.</p><p class="keyword">Params:</p><p class="simplePara">X: X Component.</p><p class="simplePara">Y: Y Component.</p><h1 class="basicHead">CONSTRUCTOR (float X, float Y, float Z)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Construct an MVector with X, Y, and Z components.</p><p class="keyword">Params:</p><p class="simplePara">X: X Component.</p><p class="simplePara">Y: Y Component.</p><p class="simplePara">Z: Z Component.</p><h1 class="basicHead">CONSTRUCTOR (Vector3 xyz)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Construct an MVector with respect to a Vector3.</p><p class="keyword">Params:</p><p class="simplePara">xyz: The Vector3's Components to set this MVector.</p><p class="basicHead">Zero</p><br><p class="simplePara">Short for writing MVector(0).</p><p class="basicHead">Right</p><br><p class="simplePara">Short for writing MVector(1, 0, 0).</p><p class="basicHead">Up</p><br><p class="simplePara">Short for writing MVector(0, 1, 0).</p><p class="basicHead">Forward</p><br><p class="simplePara">Short for writing MVector(0, 0, 1).</p><p class="basicHead">One</p><br><p class="simplePara">Short for writing MVector(1).</p><p class="basicHead">_2D</p><br><p class="simplePara">1 on XY components. 2D MVector Flag.</p><p class="basicHead">_3D</p><br><p class="simplePara">1 on XZ components. 3D MVector Flag.</p><p class="basicHead">NaN</p><br><p class="simplePara">NaN on all components.</p><h1 class="basicHead">V3 (MVector mVector)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Converts an MVector to a Vector3.</p><p class="keyword">Params:</p><p class="simplePara">mVector: The MVector to convert.</p><h1 class="basicHead">MV (Vector3 vVector)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Converts a Vector3 to an MVector.</p><p class="keyword">Params:</p><p class="simplePara">vVector: The Vector3 to convert.</p><h1 class="basicHead">Normalise ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Normalises V.</p><h1 class="basicHead">Cross ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The vector cross ^ product of Left and Right.</p><h1 class="basicHead">Dot ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The vector dot | product of Left and Right.</p><p class="keyword">Remarks:</p><p class="simplePara">Does not assume Left and Right are normalised.</p><h1 class="basicHead">Parallel (MVector Left, MVector Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Whether left and right are Mathematics.Parallel(MVector, MVector, float) to each other.</p><h1 class="basicHead">MVectorFromAngle (float Degrees, EDirection Forward)</h1><br><p class="keyword">Summary:</p><p class="simplePara">A normalised MVector at Degrees, relative to Forward.</p><p class="keyword">Params:</p><p class="simplePara">Degrees: The angle offset.</p><p class="simplePara">Forward: The forward direction.</p><h1 class="basicHead">Distance (MVector Left, MVector Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">The distance between Left and Right.</p><p class="keyword">Params:</p><p class="simplePara">Left: Source of the distance.</p><p class="simplePara">Right: Distance from source.</p><h1 class="basicHead">SqrDistance (MVector Left, MVector Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Square Euclidean distance between Left and Right.</p><p class="basicHead">SqrMagnitude</p><br><p class="simplePara">The square magnitude of this MVector.</p><p class="basicHead">Magnitude</p><br><p class="simplePara">The magnitude of this MVector.</p><p class="basicHead">Abs</p><br><p class="simplePara">The Mathf.Abs(float) of this MVector's components.</p><p class="basicHead">Normalised</p><br><p class="simplePara">The normalised version of this MVector.</p><h1 class="basicHead">Normalise ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Normalises this MVector.</p><h1 class="basicHead">Set ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Sets this MVector's components.</p><h1 class="basicHead">IsNormalised ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Whether this MVector is a unit vector. (If this MVector is Mathematics.IsNormalised(MVector).</p><p class="keyword">Returns:</p><p class="simplePara">True if this MVector has a magnitude of one.</p><h1 class="basicHead">Mirror (MVector Normal)</h1><br><p class="keyword">Summary:</p><p class="simplePara">This MVector's reflection among Normal.</p><p class="keyword">Params:</p><p class="simplePara">Normal: The normal vector to mirror.</p><h1 class="basicHead">RotateAngleAxis (float AngleDegrees, MVector Axis)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Rotates this MVector at an angle of AngleDegrees around Axis.</p><p class="keyword">Params:</p><p class="simplePara">AngleDegrees: The degrees at which to rotate this MVector.</p><p class="simplePara">Axis: The axis to rotate this MVector around.</p><h1 class="basicHead">Rotation ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Converts a normalised vector to a Pitch, Yaw rotation.</p><p class="keyword">Remarks:</p><p class="simplePara">Roll is zero.</p><p class="keyword">Returns:</p><p class="simplePara">An MRotator defining the pitch and yaw of this direction vector.</p><h1 class="basicHead">DirectionAndLength (MVector&  Direction, Single&  Length)</h1><br><p class="keyword">Summary:</p><p class="simplePara">The direction and length of this MVector.</p><h1 class="basicHead">Projection ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">This MVector's projection.</p><h1 class="basicHead">IgnoreX ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Ignores the X component of this MVector.</p><p class="keyword">Remarks:</p><p class="simplePara">Modifies this MVector.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector with a zeroed X component.</p><h1 class="basicHead">IgnoreY ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Ignores the Y component of this MVector.</p><p class="keyword">Remarks:</p><p class="simplePara">Modifies this MVector.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector with a zeroed Y component.</p><h1 class="basicHead">IgnoreZ ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Ignores the Z component of this MVector.</p><p class="keyword">Remarks:</p><p class="simplePara">Modifies this MVector.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector with a zeroed Z component.</p><h1 class="basicHead">Ignore (EComponentAxis Components)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Ignores a set of Components on this MVector.</p><p class="keyword">Params:</p><p class="simplePara">Components: The vector components to ignore.</p><p class="keyword">Returns:</p><p class="simplePara">This MVector zeroed over Components.</p><h1 class="basicHead">Distance (MVector V)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Euclidean distance between this MVector and another V.</p><p class="keyword">Params:</p><p class="simplePara">V: The MVector to find distance.</p><p class="keyword">Returns:</p><p class="simplePara">The Euclidean distance between this MVector and V.</p><h1 class="basicHead">SqrDistance (MVector V)</h1><br><p class="keyword">Summary:</p><p class="simplePara">The Euclidean distance, but without the square root calculation.</p><p class="keyword">Params:</p><p class="simplePara">V: The MVector to find square distance.</p><p class="keyword">Returns:</p><p class="simplePara">The square distance between this MVector and V.</p><h1 class="basicHead">op_Addition (MVector Left, MVector Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Adds two MVectors together.</p><p class="keyword">Params:</p><p class="simplePara">Left: Left-side MVector.</p><p class="simplePara">Right: Right-side MVector.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, MVector Right) => new MVector(Left.X + Right.X, Left.Y + Right.Y, Left.Z + Right.Z)</p><h1 class="basicHead">op_Addition (MVector Left, Vector3 Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Adds a Vector3 to an MVector.</p><p class="keyword">Params:</p><p class="simplePara">Left: The MVector.</p><p class="simplePara">Right: The Vector3.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, Vector3 Right) => Left + (MVector)Right</p><h1 class="basicHead">op_Addition (Vector3 Left, MVector Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Adds an MVector to a Vector3.</p><p class="keyword">Params:</p><p class="simplePara">Left: The Vector3.</p><p class="simplePara">Right: The MVector.</p><p class="keyword">Returns:</p><p class="simplePara">(Vector3 Left, MVector Right) => (MVector)Left + Right</p><h1 class="basicHead">op_Subtraction (MVector Left, MVector Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Subtracts two MVectors.</p><p class="keyword">Params:</p><p class="simplePara">Left: Left-side MVector.</p><p class="simplePara">Right: Right-side MVector.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, MVector Right) => new MVector(Left.X - Right.X, Left.Y - Right.Y, Left.Z - Right.Z)</p><h1 class="basicHead">op_UnaryNegation (MVector V)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Negates an MVector.</p><p class="keyword">Params:</p><p class="simplePara">V: The MVector to negate all components.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector V) => V *= -1f</p><h1 class="basicHead">op_Multiply (float S, MVector V)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Multiplies an MVector by a scalar on all components.</p><p class="keyword">Params:</p><p class="simplePara">S: The Scalar to multiply.</p><p class="simplePara">V: The MVector.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector V, float S) => new MVector(V.X * S, V.Y * S, V.Z * S)</p><h1 class="basicHead">op_Division (MVector V, float D)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Divides an MVector by a scalar on all components.</p><p class="keyword">Remarks:</p><p class="simplePara">If d == 0, this will throw a DivideByZeroException.</p><p class="keyword">Params:</p><p class="simplePara">V: The MVector.</p><p class="simplePara">D: The denominator under all components.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector V, float D) => float S = 1 / D; return S * V</p><h1 class="basicHead">op_ExclusiveOr ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The vector cross ^ product.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, MVector Right) => new MVector(Left.Y * Right.Z - Left.Z * Right.Y, Left.Z * Right.X - Left.X * Right.Z, Left.X * Right.Y - Left.Y * Right.X)</p><h1 class="basicHead">op_BitwiseOr ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The vector dot | product.</p><p class="keyword">Remarks:</p><p class="simplePara">Does not assume Left and Right are normalised.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector Left, MVector Right) => Left.X * Right.X + Left.Y * Right.Y + Left.Z * Right.Z</p><h1 class="basicHead">op_GreaterThan ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Normalised direction from to.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector From, MVector To) => (To - From).Normalised</p><h1 class="basicHead">op_LessThan ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Normalised direction from to.</p><p class="keyword">Returns:</p><p class="simplePara">(MVector To, MVector From) => From > To</p><h1 class="basicHead">op_RightShift (MVector V, int I)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Shifts all components to the right.</p><p class="keyword">Params:</p><p class="simplePara">V: The MVector to shift.</p><p class="simplePara">I: The number of times to shift right.</p><p class="keyword">Returns:</p><p class="simplePara">X = Y, Y = Z, Z = X.</p><h1 class="basicHead">op_LeftShift (MVector V, int I)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Shifts all components to the left.</p><p class="keyword">Params:</p><p class="simplePara">V: The MVector to shift.</p><p class="simplePara">I: The number of times to shift left.</p><p class="keyword">Returns:</p><p class="simplePara">X = Z, Y = X, Z = Y.</p><h1 class="basicHead">op_Equality (MVector Left, MVector Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Compares two MVectors for equality.</p><p class="keyword">Params:</p><p class="simplePara">Left: Left-side comparison.</p><p class="simplePara">Right: Right-side comparison.</p><p class="keyword">Returns:</p><p class="simplePara">True if the square distance between Left and Right is less than kEpsilon * kEpsilon.</p><h1 class="basicHead">op_Inequality (MVector Left, MVector Right)</h1><br><p class="keyword">Summary:</p><p class="simplePara">Compares two MVectors for inequality.</p><p class="keyword">Params:</p><p class="simplePara">Left: Left-side comparison.</p><p class="simplePara">Right: Right-side comparison.</p><p class="keyword">Returns:</p><p class="simplePara">The opposite of operator ==.</p><h1 class="basicHead">op_Implicit ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Automatic conversion from an MVector to a Vector3.</p><h1 class="basicHead">op_Implicit ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Automatic conversion from an MVector to a Vector2.</p><p class="keyword">Remarks:</p><p class="simplePara">Only the X and Y components are considered. The Z component is ignored.</p><h1 class="basicHead">op_Implicit ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Automatic conversion from a Vector3 to an MVector.</p><h1 class="basicHead">op_Implicit ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Automatic conversion from a Vector2 to an MVector.</p><p class="keyword">Remarks:</p><p class="simplePara">The resulting MVector will have a Z equal to zero.</p><h1 class="basicHead">op_Implicit ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">The Colour representation of this MVector, in 0-255 XYZ/RGB.</p><h1 class="basicHead">GetHashCode ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">Hash code for use in Maps, Sets, MArrays, etc.</p><p class="keyword">Returns:</p><p class="simplePara">GetHashCode() => X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2)</p><h1 class="basicHead">ToString ()</h1><br><p class="keyword">Summary:</p><p class="simplePara">A human-readable MVector.</p><p class="keyword">Returns:</p><p class="simplePara">ToString() => "X: " + X + " Y: " + Y + " Z: " + Z</p></div></div></div></body></html>